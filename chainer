#!/usr/bin/python3

import mysql.connector
import yaml
import sys
import os
import re

if len(sys.argv) < 3:
	print('./chainer <seedsFilePath> <configFilePath>')
	quit()

global config
global seeds

with open(str(sys.argv[2])) as configFile:
	config = yaml.load(configFile, Loader=yaml.FullLoader)
with open(str(sys.argv[1])) as seedsFile:
	seeds = seedsFile.readlines()

dbUser = config[0]['dbUser']
dbPass = config[0]['dbPass']

print('running setup')
for command in config[0]['commands']:
	process = os.popen(command)
	output = process.read().strip()
	print('Total Lines ' + str(len(output)))

print('setup complete')
dbconnection = mysql.connector.connect(host="localhost", database='chainer', user='root', password='password')
dbcursor = dbconnection.cursor()

CHAINER_COMMAND_CONST = r"(\${).*(}\$)"
CHAINER_COMMAND_PREFIX_CONST = '(\${)'
CHAINER_COMMAND_POSTFIX_CONST = '(}\$)'
DB_CONST = 'db'
INPUT_CONST = '(\${INPUT}\$)'
RESULT_CONST = '(\${RESULT}\$)'
EMPTY = ''

def checkIfRowExists(table, column, value):
	sql = "select count(*) from " + table + " where " + column +" = '" + value + "';"
	dbcursor.execute(sql)
	count = dbcursor.fetchone()
	return count[0] > 0

def getDataFromDb(table, column):
	print('Getting db.' + table + '.' + column)
	sql = "select " + column + " from " + table + ";"
	dbcursor.execute(sql)
	return dbcursor.fetchall()

def storeDataInDb(table, column, data):
	print('Storing results in db.'+table+'.'+column)

	input = []
	for line in data:
		entry = line.strip()
		if not checkIfRowExists(table, column, entry):
			input.append(str(entry))

	print('Storing %s rows', str(len(input)))

	if len(input) > 0:
		params = ['(null, %s)' for item in input]
		sql = 'INSERT INTO ' + table + ' (id, ' + column +') VALUES %s;' % ','.join(params)
		dbcursor.execute(sql, input)
		dbconnection.commit()

def getCommand(chainerCommand):
	command = re.sub(CHAINER_COMMAND_PREFIX_CONST, EMPTY, chainerCommand)
	command = re.sub(CHAINER_COMMAND_POSTFIX_CONST, EMPTY, command)
	return command

def processInputChainerCommand(chainerCommand):
	command = getCommand(chainerCommand)
	if DB_CONST in command:
		head,table,column = command.split('.')
		return getDataFromDb(table,column)

def processOutputChainerCommand(storeLocation, data):
	command = getCommand(storeLocation)
	if DB_CONST in command:
		head,table,column = command.split('.')
		storeDataInDb(table,column,data)

def processOutputChainerSqlCommandWithInput(sql, output, input):
	sql = re.sub(RESULT_CONST, '%s', sql.strip())
	sql = re.sub(INPUT_CONST, '%s', sql.strip())
	print(sql)
	dbcursor.execute(sql, (output.strip(), input.strip()))
	dbconnection.commit()

def composeBashCommandWithInput(command, input):
	return re.sub(INPUT_CONST, input, command)

def runSqlCommand(sql):
	print('Running sql command ' + sql)
	dbcursor.execute(sql)


print('Loading seeds into db')
for seed in seeds:
	seed = seed.strip()
	if seed and not checkIfRowExists("seed","domain",seed):
		sql = "INSERT INTO seed (id,domain) VALUES (%s, %s)"
		values = (0,seed)
		dbcursor.execute(sql,values)
		dbconnection.commit()

for value in config:
	if 'name' in value.keys():
		print('Running: ' + value['name'])


	if 'run' in value.keys():
		for application in value['run']:
			cmd = application['cmd']

			if DB_CONST in cmd:
				runSqlCommand(application['sql'])
			else:
				inputCommand = application['input']
				outputObject = application['output']

				sourceFile = EMPTY
				storeLocation = EMPTY
				storeSqlCommand = EMPTY
				cleanupCommand = EMPTY
				isChainerOutputLocation = False
				isChainerSqlCommand = False

				if 'sourcefile' in outputObject:
					sourceFile = outputObject['sourcefile']
				if 'store' in outputObject:
					print('Store Found')
					print(outputObject['store'])

					if 'location' in outputObject['store']:
						storeLocation = outputObject['store']['location'].strip()
						print('Store Location: ' + storeLocation)
						isChainerOutputLocation = re.search(CHAINER_COMMAND_CONST, storeLocation)

					if 'sql' in outputObject['store']:
						print(outputObject['store']['sql'])
						storeSqlCommand = outputObject['store']['sql'].strip()
						isChainerSqlCommand = True

				if 'cleanup' in application:
					cleanupCommand = application['cleanup']['cmd']

				chainerCommand = re.search(CHAINER_COMMAND_CONST, inputCommand)

				if chainerCommand:
					for item in processInputChainerCommand(chainerCommand.group()):
						try:
							inputData = item[0].strip()
							command = composeBashCommandWithInput(cmd, inputData)
							print('Running: ' + command)
							process = os.popen(command)
							outputData = process.read() #doing this because it seams the command doesn't wait to complete if we don't read it

							if sourceFile:
								outputData = open(sourceFile, 'r').readlines()

							if 'cmd' in outputObject:
								process = os.popen(outputObject['cmd'])
								outputData = process.read()

							if outputData and isChainerOutputLocation:
								print('Processing output')
								processOutputChainerCommand(storeLocation, outputData)

							if outputData and isChainerSqlCommand:
								print('Storing output in db')
								processOutputChainerSqlCommandWithInput(storeSqlCommand, outputData, inputData)

							if cleanupCommand:
								os.popen(cleanupCommand)
								print(cleanupCommand)

						except Exception as error:
							print(error)

