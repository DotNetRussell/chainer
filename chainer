#!/usr/bin/python3

import mysql.connector
import yaml
import sys
import os
import re

banner="""
    _,aaaaaaaaaaaaaaaaaaa,_                _,aaaaaaaaaaaaaaaaaaa,_
  ,P"                     "Y,            ,P"                     "Y,
 d'    ,aaaaaaaaaaaaaaa,    `b          d'    ,aaaaaaaaaaaaaaa,    `b
d'   ,d"            ,aaabaaaa8aaaaaaaaaa8aaaadaaa,            "b,   `b
I    I              I          Chainer           I              I    I
Y,   `Y,            `aaaaaaaaaaaaaaaaaaaaaaaaaaaa'             P'   ,P
 Y,   `baaaaaaaaaaaaaaad'   ,P          Y,   `baaaaaaaaaaaaaaId'   ,P
  `b,                     ,d'            `b,                     ,d'
    `baaaaaaaaaaaaaaaaaaad'                `baaaaaaaaaaaaaaaaaaad'
"""

print(banner)

if len(sys.argv) < 3:
	print('./chainer <seedsFilePath> <configFilePath>')
	quit()

global config
global seeds

with open(str(sys.argv[2])) as configFile:
	config = yaml.load(configFile, Loader=yaml.FullLoader)
with open(str(sys.argv[1])) as seedsFile:
	seeds = seedsFile.readlines()

dbUser = config[0]['dbUser']
dbPass = config[0]['dbPass']

print('running setup')
for command in config[0]['commands']:
	process = os.popen(command)
	output = process.read().strip()

print('setup complete')
dbconnection = mysql.connector.connect(host="localhost", database='chainer', user='root', password='password')
dbcursor = dbconnection.cursor()

CHAINER_COMMAND_CONST = r"(\${).*(}\$)"
CHAINER_DELIM_CONST = "&"
CHAINER_COMMAND_PREFIX_CONST = '(\${)'
CHAINER_COMMAND_POSTFIX_CONST = '(}\$)'
DB_CONST = 'db'
INPUT_CONST = '(\${INPUT}\$)'
RESULT_CONST = '(\${RESULT}\$)'
EMPTY = ''

def checkIfRowExists(table, column, value):
	sql = "select count(*) from " + table + " where " + column +" = '" + value + "';"
	dbcursor.execute(sql)
	count = dbcursor.fetchone()
	return count[0] > 0

def getDataFromDb(table, column):
	print('Getting db.' + table + '.' + column)
	sql = "select distinct " + column + " from " + table + ";"
	dbcursor.execute(sql)
	return dbcursor.fetchall()

def getDataFromDbTwoColumns(table, column1, column2):
	sql = "select " + column1 + "," + column2 + " from " + table + ";"
	dbcursor.execute(sql)
	return dbcursor.fetchall()

def storeDataInDb(table, column, data):
	print('Storing results in db.'+table+'.'+column)

	input = []
	for line in data:
		entry = line.strip()
		if not checkIfRowExists(table, column, entry):
			input.append(str(entry))
	if len(input) > 0:
		params = ['(null, %s)' for item in input]
		sql = 'INSERT INTO ' + table + ' (id, ' + column +') VALUES %s;' % ','.join(params)
		dbcursor.execute(sql, input)
		dbconnection.commit()

def getCommand(chainerCommand):
	command = re.sub(CHAINER_COMMAND_PREFIX_CONST, EMPTY, chainerCommand)
	command = re.sub(CHAINER_COMMAND_POSTFIX_CONST, EMPTY, command)
	return command

def processInputChainerCommand(chainerCommand):
	command = getCommand(chainerCommand)
	if DB_CONST in command and CHAINER_DELIM_CONST not in command:
		head,table,column = command.split('.')
		return getDataFromDb(table,column)
	elif DB_CONST in command and CHAINER_DELIM_CONST in command:
		com1, com2 = command.split('&')
		head1,table1,column1 = com1.split('.')
		head2,table2,column2 = com2.split('.')
		if table1 == table2:
			return getDataFromDbTwoColumns(table1, column1, column2)

def processOutputChainerCommand(storeLocation, data):
	command = getCommand(storeLocation)
	if DB_CONST in command:
		head,table,column = command.split('.')
		storeDataInDb(table,column,data)

def processOutputChainerSqlCommandWithInput(sql, output, input):
	sql = re.sub(RESULT_CONST, '%s', sql.strip())
	sql = re.sub(INPUT_CONST, '%s', sql.strip())
	dbcursor.execute(sql, (output.strip(), input.strip()))
	dbconnection.commit()

def processOutputChainerSqlCommandWithTwoInputs(sql, output, inputOne, inputTwo):
	sql = re.sub(RESULT_CONST, '%s', sql.strip())
	sql = re.sub(INPUT_CONST, '%s', sql.strip())
	dbcursor.execute(sql, (output.strip(), inputOne.strip(), inputTwo.strip()))
	dbconnection.commit()

def composeBashCommandWithInput(command, input):
	return re.sub(INPUT_CONST, input, command)

def composeBashCommandWithTwoInputs(command, inputOne, inputTwo):
	command = re.sub(INPUT_CONST, inputOne, command, 1)
	return re.sub(INPUT_CONST, inputTwo, command, 2)

def runSqlCommand(sql):
	dbcursor.execute(sql)
	dbconnection.commit()

print('Loading seeds into db')
for seed in seeds:
	seed = seed.strip()
	if seed and not checkIfRowExists("seed","domain",seed):
		sql = "INSERT INTO seed (id,domain) VALUES (%s, %s)"
		values = (0,seed)
		dbcursor.execute(sql,values)
		dbconnection.commit()

for value in config:

	if 'skipstage' in value.keys() and value['skipstage']:
		print('Skipping: ' + value['name'])
		continue

	if 'name' in value.keys():
		print('Running: ' + value['name'])

	if 'run' in value.keys():
		for application in value['run']:
			cmd = application['cmd']

			if DB_CONST in cmd:
				runSqlCommand(application['sql'])
			else:
				inputCommand = application['input']
				outputObject = application['output']

				sourceFile = EMPTY
				storeLocation = EMPTY
				storeSqlCommand = EMPTY
				cleanupCommand = EMPTY
				isChainerOutputLocation = False
				isChainerSqlCommand = False
				isDoubleChainerSqlCommand = False

				if 'sourcefile' in outputObject:
					sourceFile = outputObject['sourcefile']
				if 'store' in outputObject:

					if 'location' in outputObject['store']:
						storeLocation = outputObject['store']['location'].strip()
						isChainerOutputLocation = re.search(CHAINER_COMMAND_CONST, storeLocation)

					if 'sql' in outputObject['store']:
						storeSqlCommand = outputObject['store']['sql'].strip()
						isChainerSqlCommand = True

				if 'cleanup' in application:
					cleanupCommand = application['cleanup']['cmd']

				chainerCommand = re.search(CHAINER_COMMAND_CONST, inputCommand)

				if CHAINER_DELIM_CONST in inputCommand:
					isDoubleChainerSqlCommand = True

				if chainerCommand:
					for item in processInputChainerCommand(chainerCommand.group()):
						try:
							command = EMPTY
							inputData = EMPTY
							secondInputData = EMPTY

							if not isDoubleChainerSqlCommand:
								inputData = item[0].strip()
								command = composeBashCommandWithInput(cmd, inputData)

							else:
								inputData = item[0].strip()
								secondInputData = item[1].strip()
								command = composeBashCommandWithTwoInputs(cmd, inputData, secondInputData)
							print('Running: ' + command)
							process = os.popen(command)
							outputData = process.read() #doing this because it seams the command doesn't wait to complete if we don't read it

							if 'preoutputcmd' in outputObject:
#								print('Running output command ' + outputObject['preoutputcmd'])
								process = os.popen(outputObject['preoutputcmd'])
								outputData = process.read()

							if sourceFile:
								outputData = open(sourceFile, 'r').readlines()

							if 'postoutputcmd' in outputObject:
#								print('Running output command ' + outputObject['postoutputcmd'])
								process = os.popen(outputObject['postoutputcmd'])
								outputData = process.read()

							if outputData and isChainerOutputLocation:
								print('Processing output')
								processOutputChainerCommand(storeLocation, outputData)

							if outputData and isChainerSqlCommand:
								print('Storing output in db')
								if(isinstance(outputData, list)):
									if not isDoubleChainerSqlCommand:
										if 'nolistoutput' in outputObject:
											print('inserting ' + str(outputData) + ' with command ' + storeSqlCommand)
											processOutputChainerSqlCommandWithInput(storeSqlCommand, inputData, str(outputData))
										else:
											for line in outputData:
												print('inserting ' + line.strip() + ' with command ' + storeSqlCommand)
												processOutputChainerSqlCommandWithInput(storeSqlCommand, inputData, line)
									else:
										processOutputChainerSqlCommandWithTwoInputs(storeSqlCommand, str(outputData), inputData, secondInputData)
								else:
									processOutputChainerSqlCommandWithInput(storeSqlCommand, outputData, inputData)

							if cleanupCommand:
								os.popen(cleanupCommand)

						except Exception as error:
							print(error)
